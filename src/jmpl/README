                    JMPL - A JSON template library
                    ==============================

0. Introduction
---------------

JMPL is a template library designed to produce arbitrary text files. It
takes as input a static template (file or string) together with dynamic
(JSON) data. It then produces its output by processing the template and
replacing JMPL-specific directives with data found in (or based on) the
supplied JSON data.


1. Current Status
-----------------

The current implementation should be considered a prototype or a proof of
of concept. It was pulled together with the primary purpose of evaluating
the feasibility of using such a template library for a particular purpose
everything else being either a secondary goal or ignored altogether. This
means in practice some features expected from production-quality code are
either absent or inadequate. Among other things the following are known
problems/omissions/bugs that will probably be addressed once prototyping
is over and an eventual cleanup/refactoring/rewrit takes place:

  - the lexical analyzer/parser is hackish, primitive and non-forgiving
  - parse errors do not produce any helpful error/diagnostic info, you
    have to turn on full debugging even to find out where the problem
    occured, or rather was detected, in the input
  - the parser can only parse fully parenthesized binary expressions of
    logical and/or relational operators
  - the whitespace-handling strategy is broken, occasionally producing
    unwanted side-effects (eating whitespace or producing extra one)
  - the grammar syntax has various inconsistencies which will be fixed
    during the cleanup
      o some block constructs are defined in a do-else-end fashion while
        others omit the beginning do
      o variable-testing constructs have the test variable after the
        directive while the trail-check construct has the test-string
        inside the directive


2. Template Format
------------------

The template file is a text file that consist of text which is (mostly)
verbatim copied to the output and directives which are processed and
evaluated in the context of the input JSON data. Some directives are
simple and self-contained. Others are complex and together form one or
more blocks within the template. For instance a JSON variable reference
or an omitted tabulation marker are examples of a simple directive. An
if-else or a for-each block are typical examples of a block directive.

Every template file starts with a mandatory declaration of directive de-
limiters and an optional declaration of the omitted tabulation marker,
all separated by whitespace.

The directive delimiters are strings that mark the beginning and the end
of any directive that carries special meaning for the template processor.
These strings are not allowed as part of the input other than for marking
directives. This is the primary reason why they need to be declared: you
must choose them so that they do not conflict with the rest (verbatimly
copied part) of your template. The choice of directive start and end
markers have a few limitations: they cannot contain whitespace or newlines
and neither is allowed to be a substring of the other.

If specified, the optional tabulation marker declares which string is used
after a newline to indicate that the leading part of the line is just
tabulation for readability. Any repeated sequence of the first character
after a tabulation marker is omitted from the output.

For instance the line

{ } >

declares { and } as the declarative delimiters and > as the tabulation
marker. The following template with such a delcaration

{ } >
Hello, the value for foobar is '{data.foobar}'.
{if} ({data.foo} == 'bar') {then}
>    Whaddayaknow... foo was set to 'bar'.
{else}
>    Oh boy... foo was set to '{data.foo}' instead of 'bar'.
{end}

if evaluated with the JSON data

{
  'foo': 'xyzzy',
  'foobar': 'barfoo',
}

would produce the output

Hello, the value for foobar is 'barfoo'.
Oh boy... foo was set to 'xyzzy' instead of 'bar'.


3. Supported Directives
-----------------------

Currently the following directives are supported by the template
processor (we use { and } as the directive delimiters):

  - Variable substitution:

      {variable} is replaced with the given JSON value, or loop variable.

    Example:

      JSON gave us '{data.foo}' as the value of foo.
      JSON gave us '{data.bar[0].xyzzy[3].whatever}' as another value.
      {foreach} key:value {in} {data.dictionary} {do}
      >    {key} = {value}
      {end}


  - #ifdef-like if-set:

      {if-set} <variable> {then}
         <if-set block>
      {else}
         <if-unset block>
      {end}

    Evaluate if <variable> is set and execute either block accordingly. The
    else branch/block is optional and can be omitted.

  - if-else

      {if} <test-expression> {then}
         <test-true block>
      {else}
         <test-false block>
      {end}

    Evaluate <test-expression> and execute either block accordingly. The
    else branch/block is optional and can be omitted.

  - foreach

      {foreach} <key:val>|<key:>|<:val> {in} <variable> {do}
         <body>
      {end}

    Set key and val, key, or val depending on what is requested to all
    respective values found in the given variable (dictionary or array,
    or even a plain JSON string) and evaluate <body> with each.

  - ?first, !first, ?last, !last

      {?first|!first|?last|!last} <loop-variable>
         <true-body>
      {else}
         <false-body>
      {end}

    Check if the (innermost) loop with the given variable is at the
    first, non-first, last, non-last iteration and execute either
    block accordingly. The else branch/block is optional and can be omitted.

    Example:

      {foreach} key:value {in} {data.manifest.environment} {do}
      >     {?first}key [ {end}{key}={value}{!last}key, {else} ] {end}
      {end}

  - ?trail:<str>, !trail:<str>

      {?trail|!trail:<str>}
         <true-body>
      {else}
         <false-body>
      {end}

    Check if the given string matches/mismatches the trailing part of the
    output prodiced so far and evaluate either block accordingly. The else
    branch/block is optional and can be omitted.

    Example: (see below for macro definitions)

      {macro} ENSURE-NL {!trail:\n}{\n}{end}{end}

   - macro declaration

      {macro} NAME <body> {end}

     Declare NAME to be a shorthand for <body> and evaluate <body> whenever
     NAME is dereferenced by substitution.

     Example:

      {macro} R {data.path.container}/{data.provider}-{data.manifest.app}{end}
      {macro} SYMLINK /bin/ln -sf{end}
      {macro} ENSURE-NL {!trail:\n}{\n}{end}{end}

      [general]
      {SYMLINK} usr/sbin {R}/sbin
      {SYMLINK} usr/bin {R}/bin
      {SYMLINK} usr/lib {R}/lib
      {SYMLINK} usr/lib64 {R}/lib64

      [foo]
      {data.foo}
      {ENSURE-NL}
      [bar]
      {data.bar}
      {ENSURE-NL}


4. Variable Evaluation
----------------------

The parser is a single-pass recursive descent parser. Runtime evaluation
is also single-pass so variables are evaluated once. Don't try any fancy-
pant recursive evaluations like {{foo}} or {foo{bar}}... it's not supposed
to work. However, things like iterating arrays of arrays with a nested
foreach loop should work. Also variables references in macros are evaluated
runtime, so you can have macros with variable or macro references if you
use these macros in a contect where the variables are valid (or you check
for the validity of the variable and branch accordingly in the body of the
macro).


5. Debugging / What To Do When Things Go Wrong
----------------------------------------------

Since the prototype implementation currently does not collect
or produce reasonable disagnostic messages about parse errors,
your only chance is to run the parser with full debugging and
see where things go wrong. In the code that's practically done
with iot_debug_enable(true); iot_debug_set("*");


6. Occasionally Unpredictable/Mysterious Whitespace (\n) Behavior
-----------------------------------------------------------------

Yup... See 1)


X. Other Examples
-----------------

...TODO...


